use std::str::FromStr;
use crate::datum::DataType;
use crate::expr::BinaryOp;
use crate::parser::ast::*;

grammar;

pub Statements = Semicolon<Statement>;
pub Fields = Comma<Field>;
pub Exprs = Comma<Expr>;
pub Tuples = Comma<Tuple>;
pub WhereExprs = And<Expr>;
pub Identifiers = Comma<Identifier>;

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(stmt) => {
            v.push(stmt);
            v
        }
    },
};

Semicolon<T>: Vec<T> = {
    <mut v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(stmt) => {
            v.push(stmt);
            v
        }
    },
};

And<T>: Vec<T> = {
    <mut v:(<T> "and")*> <e:T?> => match e {
        None => v,
        Some(stmt) => {
            v.push(stmt);
            v
        }
    },
}

BooleanExpr: ExprNode = {
    <binary_expr: BinaryExpr> => ExprNode::Binary(binary_expr),
}

ValueExpr: ExprNode = {
    <constant_expr: ConstantExpr> => ExprNode::Constant(constant_expr),
    <column_ref_expr: ColumnRefExpr> => ExprNode::ColumnRef(column_ref_expr),
}

pub Expr: ExprNode = {
    BooleanExpr,
    ValueExpr,
}

BinaryExpr: BinaryExprNode = {
    <lhs: ValueExpr> "=" <rhs: ValueExpr> => BinaryExprNode { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinaryOp::Equal },
    <lhs: ValueExpr> "<" <rhs: ValueExpr> => BinaryExprNode { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinaryOp::LessThan },
    <lhs: ValueExpr> ">" <rhs: ValueExpr> => BinaryExprNode { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinaryOp::GreaterThan },
}

ColumnRefExpr: ColumnRefExprNode = {
    <column_name: Identifier> => ColumnRefExprNode { column_name },
}

ConstantExpr: ConstantExprNode = {
    <num: Num> => ConstantExprNode { value: ConstantValue::Int(num) },
    <str: Str> => ConstantExprNode { value: ConstantValue::String(str) },
    "null" => ConstantExprNode { value: ConstantValue::Null },
    "NULL" => ConstantExprNode { value: ConstantValue::Null }
};

DataType: DataType = {
    "int" "not" "null" => DataType::new_int(false),
    "int" "null" => DataType::new_int(true),
    "char" "(" <width:Num> ")" "not" "null" => DataType::new_char(width as usize, false),
    "char" "(" <width:Num> ")" "null" => DataType::new_char(width as usize, true),
    "varchar" "not" "null" => DataType::new_varchar(false),
    "varchar" "null" => DataType::new_varchar(true),
    "bool" "not" "null" => DataType::new_bool(false),
    "bool" "null" => DataType::new_bool(true),
}

Field: Field = {
    NormalField,
    PrimaryField,
    ForeignField,
}

PrimaryField: Field = "primary" "key" "(" <column_names: Identifiers> ")" 
    => Field::Primary(PrimaryField { column_names });

ForeignField: Field = "foreign" "key" "(" <column_names: Identifiers> ")" "references" <ref_table_name: Identifier> "(" <ref_column_names: Identifiers> ")"
    => Field::Foreign(ForeignField { column_names, ref_column_names, ref_table_name });

NormalField: Field = <field_name:Identifier> <field_data_type:DataType> => Field::Normal(NormalField { field_name, field_data_type });

pub Statement: Statement = {
    CreateDatabaseStmt,
    ShowDatabasesStmt,
    UseDatabaseStmt,
    CreateTableStmt,
    InsertStmt,
    DescStmt,
    SelectStmt,
    AddIndexStmt,
    DropTableStmt,
    DeleteStmt,
}

DropTableStmt: Statement = "drop" "table" <table_name: Identifier> ";" => Statement::DropTable(DropTableStmt { table_name });

WhereClauses: Vec<ExprNode> = "where" <exprs: WhereExprs> => exprs;

Selectors: Selectors = {
    "*" => Selectors::All,
    <exprs: Exprs> => Selectors::Exprs(exprs),
}

AddIndexStmt: Statement = "alter" "table" <table_name: Identifier> "add" "index" "("<exprs: Exprs> ")" ";" 
    => Statement::AddIndex(AddIndexStmt { table_name, exprs });

SelectStmt: Statement = "select" <selectors: Selectors> "from" <table_name: Identifier> <where_exprs: WhereClauses?> ";" 
    => Statement::Select(SelectStmt { table_name, selectors, where_exprs });

DeleteStmt: Statement = "delete" "from" <table_name: Identifier> <where_exprs: WhereClauses?> ";" 
    => Statement::Delete(DeleteStmt { table_name, where_exprs, });

DescStmt: Statement = "desc" <table_name: Identifier> ";" => Statement::Desc(DescStmt { table_name });

CreateDatabaseStmt: Statement = "create" "database" <database_name: Identifier> ";" => Statement::CreateDatabase(CreateDatabaseStmt { database_name });

ShowDatabasesStmt: Statement = "show" "databases" ";" => Statement::ShowDatabases;

UseDatabaseStmt: Statement = "use" <database_name: Identifier> ";" => Statement::UseDatabase(UseDatabaseStmt { database_name });

CreateTableStmt: Statement = "create" "table" <table_name: Identifier> "(" <fields: Fields> ")" ";" => Statement::CreateTable(CreateTableStmt { table_name, fields });

InsertStmt: Statement = "insert" "into" <table_name: Identifier> "values" <values: Tuples> ";" => Statement::Insert(InsertStmt { table_name, values });

Identifier: String = {
    r"[a-zA-Z_][a-zA-Z_0-9]*" => String::from_str(<>).unwrap(),
}

Tuple: Vec<ExprNode> = "(" <exprs: Exprs> ")" => exprs;

Num: i32 = <s:r"[0-9]+"> => i32::from_str(s).unwrap();

Str: String = r#"'[a-zA-Z_0-9]+'"# => {
    let quoted = String::from_str(<>).unwrap();
    let len = quoted.len();
    quoted[1..len - 1].into()
};
