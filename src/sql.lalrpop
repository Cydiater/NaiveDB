use std::str::FromStr;
use crate::datum::DataType;
use crate::expr::BinaryOp;
use crate::parser::ast::*;
use chrono::NaiveDate;

grammar;

pub Statements = Semicolon<Statement>;
pub Fields = Comma<Field>;
pub Exprs = Comma<Expr>;
pub Tuples = Comma<Tuple>;
pub WhereExprs = And<Expr>;
pub Identifiers = Comma<Identifier>;

match {
	r"[0-9]+\-[0-9]+\-[0-9]+",
	r"[a-z]+[.]csv",
} else {
	_
}

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(stmt) => {
            v.push(stmt);
            v
        }
    },
};

Semicolon<T>: Vec<T> = {
    <mut v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(stmt) => {
            v.push(stmt);
            v
        }
    },
};

And<T>: Vec<T> = {
    <mut v:(<T> "and")*> <e:T?> => match e {
        None => v,
        Some(stmt) => {
            v.push(stmt);
            v
        }
    },
}

BooleanExpr: ExprNode = {
    <binary_expr: BinaryExpr> => ExprNode::Binary(binary_expr),
}

ValueExpr: ExprNode = {
    <constant_expr: ConstantExpr> => ExprNode::Constant(constant_expr),
    <column_ref_expr: ColumnRefExpr> => ExprNode::ColumnRef(column_ref_expr),
}

pub Expr: ExprNode = {
    BooleanExpr,
    ValueExpr,
}

BinaryExpr: BinaryExprNode = {
    <lhs: ValueExpr> "=" <rhs: ValueExpr> => BinaryExprNode { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinaryOp::Equal },
    <lhs: ValueExpr> "<" <rhs: ValueExpr> => BinaryExprNode { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinaryOp::LessThan },
    <lhs: ValueExpr> ">" <rhs: ValueExpr> => BinaryExprNode { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinaryOp::GreaterThan },
}

ColumnRefExpr: ColumnRefExprNode = {
    <column_name: Identifier> => ColumnRefExprNode { 
		table_name: None,
		column_name 
	},
	<table_name: Identifier> "." <column_name: Identifier> => ColumnRefExprNode {
		table_name: Some(table_name),
		column_name,
	},
}

ConstantExpr: ConstantExprNode = {
    <num: Real> => ConstantExprNode { value: ConstantValue::Real(num) },
    <str: Str> => ConstantExprNode { value: ConstantValue::String(str) },
	<date: Date> => ConstantExprNode { value: ConstantValue::Date(date) },
    "null" => ConstantExprNode { value: ConstantValue::Null },
    "NULL" => ConstantExprNode { value: ConstantValue::Null }
};

DataType: DataType = {
    INT NOT NULL => DataType::new_as_int(false),
    INT NULL? => DataType::new_as_int(true),
    VARCHAR MaxLength? NOT NULL => DataType::new_as_varchar(false),
    VARCHAR MaxLength? NULL?  => DataType::new_as_varchar(true),
    "bool" "not" "null" => DataType::new_as_bool(false),
    "bool" "null"? => DataType::new_as_bool(true),
	DATE NOT NULL => DataType::new_as_date(false),
	DATE NULL? => DataType::new_as_date(true),
	FLOAT NOT NULL => DataType::new_as_float(false),
	FLOAT NULL?  => DataType::new_as_float(true),
}

Field: Field = {
    NormalField,
    PrimaryField,
    ForeignField,
    UniqueField,
}

UniqueField: Field = UNIQUE "(" <column_names: Identifiers> ")"
    => Field::Unique(UniqueField { column_names });

PrimaryField: Field = PRIMARY KEY "(" <column_names: Identifiers> ")" 
    => Field::Primary(PrimaryField { column_names });

ForeignField: Field = FOREIGN KEY "(" <column_names: Identifiers> ")" REFERENCES <ref_table_name: Identifier> "(" <ref_column_names: Identifiers> ")"
    => Field::Foreign(ForeignField { column_names, ref_column_names, ref_table_name });

NormalField: Field = <field_name:Identifier> <field_data_type:DataType> 
    => Field::Normal(NormalField { field_name, field_data_type });

pub Statement: Statement = {
    CreateDatabaseStmt,
    ShowDatabasesStmt,
    UseDatabaseStmt,
    CreateTableStmt,
    InsertStmt,
    DescStmt,
    SelectStmt,
    AddIndexStmt,
    DropTableStmt,
    DeleteStmt,
	LoadFromFileStmt,
}

DropTableStmt: Statement = "drop" "table" <table_name: Identifier> ";" => Statement::DropTable(DropTableStmt { table_name });

WhereClauses: Vec<ExprNode> = "where" <exprs: WhereExprs> => exprs;

Selectors: Selectors = {
    "*" => Selectors::All,
    <exprs: Exprs> => Selectors::Exprs(exprs),
	<action: AggAction> "(" <target: AggTarget> ")" => Selectors::Agg {
		target,
		action,
	},
};


AggAction: AggAction = {
	SUM => AggAction::Sum,
	AVG => AggAction::Avg,
	MAX => AggAction::Max,
	CNT => AggAction::Cnt,
};

AggTarget: AggTarget = {
	"*" => AggTarget::All,
	<expr: Expr> => AggTarget::Expr(expr),
};

AddIndexStmt: Statement = ALTER "table" <table_name: Identifier> "add" "index" "("<exprs: Exprs> ")" ";" 
    => Statement::AddIndex(AddIndexStmt { table_name, exprs });

SelectStmt: Statement = 
	"select" 
		<selectors: Selectors> 
	"from" 
		<table_names: Identifiers> 
	<where_exprs: WhereClauses?> 
	";" 
    => 
	Statement::Select(SelectStmt { 
		table_names, 
		selectors, 
		where_exprs: where_exprs.unwrap_or_else(|| vec![]),
	});

DeleteStmt: Statement = 
	"delete" 
	"from" 
	<table_name: Identifier> 
	<where_exprs: WhereClauses?> 
	";" 
    => 
	Statement::Delete(DeleteStmt { 
		table_name, 
		where_exprs: where_exprs.unwrap_or_else(|| vec![]),
	});

DescStmt: Statement = "desc" <table_name: Identifier> ";" => Statement::Desc(DescStmt { table_name });

CreateDatabaseStmt: Statement = "create" "database" <database_name: Identifier> ";" => Statement::CreateDatabase(CreateDatabaseStmt { database_name });

ShowDatabasesStmt: Statement = "show" "databases" ";" => Statement::ShowDatabases;

UseDatabaseStmt: Statement = "use" <database_name: Identifier> ";" => Statement::UseDatabase(UseDatabaseStmt { database_name });

CreateTableStmt: Statement = 
	CREATE TABLE 
		<table_name: Identifier> 
	"(" 
		<fields: Fields> 
	")" 

	";" 
		=> 
	Statement::CreateTable(CreateTableStmt { 
		table_name, 
	fields });

InsertStmt: Statement = 
	"insert" "into" 
		<table_name: Identifier> 
	"values" 
		<values: Tuples> 
	";"
		=> 
	Statement::Insert(InsertStmt { 
		table_name, values 
	});

LoadFromFileStmt: Statement = 
	"load" "data" "infile"
		<file_name: CsvPath>
	"into" "table"
		<table_name: Identifier>
	";"
		=>
	Statement::LoadFromFile(LoadFromFileStmt {
		table_name,
		file_name,
	});

Identifier: String = {
    r"[a-zA-Z_][a-zA-Z_0-9]*" => String::from_str(<>).unwrap(),
}

Tuple: Vec<ExprNode> = "(" <exprs: Exprs> ")" => exprs;

Real: f64 = <s:r#"[+-]?([0-9]*[.])?[0-9]+"#> => f64::from_str(s).unwrap();

Str: String = r#"'[a-zA-Z_0-9\s]+'"# => {
    let quoted = String::from_str(<>).unwrap();
    let len = quoted.len();
    quoted[1..len - 1].into()
};

CsvPath: String = r"[a-z]+[.]csv" => String::from_str(<>).unwrap();

Date: NaiveDate = r"[0-9]+\-[0-9]+\-[0-9]+"
	=> NaiveDate::from_str(<>).unwrap();

CREATE = {
	"create",
	"CREATE",
};

TABLE = {
	"table",
	"TABLE",
};

UNIQUE = {
	"unique",
	"UNIQUE",
};

PRIMARY = {
	"primary",
	"PRIMARY",
};

FOREIGN = {
	"foreign",
	"FOREIGN",
};

KEY = {
	"key",
	"KEY",
};

REFERENCES = {
	"references",
	"REFERENCES",
};

INT = {
	"int",
	"INT",
};

VARCHAR = {
	"varchar",
	"VARCHAR",
};

FLOAT = {
	"float",
	"FLOAT",
};

NOT = {
	"not",
	"NOT",
};

NULL = {
	"null",
	"NULL",
};

DATE = {
	"date",
	"DATE",
};

ALTER = {
	"alter",
	"ALTER",
};

SUM = {
	"sum",
	"SUM",
};

CNT = {
	"cnt",
	"count",
	"CNT",
	"COUNT",
};

AVG = {
	"avg",
	"AVG",
};

MAX = {
	"max",
	"MAX",
	"Max",
};

MaxLength = "(" Real ")";
